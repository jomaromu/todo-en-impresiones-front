{"ast":null,"code":"import { compose, ScannedActionsSubject, Store, createAction, StoreRootModule, StoreFeatureModule } from '@ngrx/store';\nimport { merge, Observable, Subject, defer, Notification } from 'rxjs';\nimport { ignoreElements, materialize, map, catchError, filter, groupBy, mergeMap, exhaustMap, dematerialize, take, concatMap, finalize } from 'rxjs/operators';\nimport { Injectable, Inject, InjectionToken, ErrorHandler, NgModule, Optional, Injector, SkipSelf, Self } from '@angular/core';\n/**\n * @fileoverview added by tsickle\n * Generated from: src/models.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Configures an effect created by `createEffect`.\n * @record\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from 'rxjs';\nimport * as ɵngcc2 from '@ngrx/store';\n\nfunction EffectConfig() {}\n\nif (false) {\n  /**\n   * Determines if the action emitted by the effect is dispatched to the store.\n   * If false, effect does not need to return type `Observable<Action>`.\n   * @type {?|undefined}\n   */\n  EffectConfig.prototype.dispatch;\n  /**\n   * Determines if the effect will be resubscribed to if an error occurs in the main actions stream.\n   * @type {?|undefined}\n   */\n\n  EffectConfig.prototype.useEffectsErrorHandler;\n}\n/** @type {?} */\n\n\nconst DEFAULT_EFFECT_CONFIG = {\n  dispatch: true,\n  useEffectsErrorHandler: true\n};\n/** @type {?} */\n\nconst CREATE_EFFECT_METADATA_KEY = '__@ngrx/effects_create__';\n/**\n * @record\n */\n\nfunction CreateEffectMetadata() {}\n\nif (false) {\n  /* Skipping unnamed member:\n  [CREATE_EFFECT_METADATA_KEY]: EffectConfig;*/\n}\n/**\n * @record\n * @template T\n */\n\n\nfunction EffectMetadata() {}\n\nif (false) {\n  /** @type {?} */\n  EffectMetadata.prototype.propertyName;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/effect_creator.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * \\@description\n * Creates an effect from an `Observable` and an `EffectConfig`.\n *\n * \\@usageNotes\n *\n * ** Mapping to a different action **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     map(() => FeatureActions.actionTwo())\n *   )\n * );\n * ```\n *\n *  ** Non-dispatching effects **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     tap(() => console.log('Action One Dispatched'))\n *   ),\n *   { dispatch: false }\n *   // FeatureActions.actionOne is not dispatched\n * );\n * ```\n * @template C, DT, OT, R\n * @param {?} source A function which returns an `Observable`.\n * @param {?=} config A `Partial<EffectConfig>` to configure the effect.  By default, `dispatch` is true and `useEffectsErrorHandler` is true.\n * @return {?} If `EffectConfig`#`dispatch` is true, returns `Observable<Action>`.  Else, returns `Observable<unknown>`.\n *\n */\n\n\nfunction createEffect(source, config) {\n  /** @type {?} */\n  const effect = source();\n  /** @type {?} */\n\n  const value = Object.assign(Object.assign({}, DEFAULT_EFFECT_CONFIG), config);\n  Object.defineProperty(effect, CREATE_EFFECT_METADATA_KEY, {\n    value\n  });\n  return (\n    /** @type {?} */\n    effect\n  );\n}\n/**\n * @template T\n * @param {?} instance\n * @return {?}\n */\n\n\nfunction getCreateEffectMetadata(instance) {\n  /** @type {?} */\n  const propertyNames =\n  /** @type {?} */\n  Object.getOwnPropertyNames(instance);\n  /** @type {?} */\n\n  const metadata = propertyNames.filter(\n  /**\n  * @param {?} propertyName\n  * @return {?}\n  */\n  propertyName => instance[propertyName] && instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY)).map(\n  /**\n  * @param {?} propertyName\n  * @return {?}\n  */\n  propertyName => {\n    /** @type {?} */\n    const metaData =\n    /** @type {?} */\n    instance[propertyName][CREATE_EFFECT_METADATA_KEY];\n    return Object.assign({\n      propertyName\n    }, metaData);\n  });\n  return metadata;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/utils.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n * @param {?} instance\n * @return {?}\n */\n\n\nfunction getSourceForInstance(instance) {\n  return Object.getPrototypeOf(instance);\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/effect_decorator.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst METADATA_KEY = '__@ngrx/effects__';\n/**\n * @param {?=} config\n * @return {?}\n */\n\nfunction Effect(config = {}) {\n  return (\n    /**\n    * @template T, K\n    * @param {?} target\n    * @param {?} propertyName\n    * @return {?}\n    */\n    function (target, propertyName) {\n      /** @type {?} */\n      const metadata = Object.assign(Object.assign(Object.assign({}, DEFAULT_EFFECT_CONFIG), config), {\n        // Overrides any defaults if values are provided\n        propertyName\n      });\n      addEffectMetadataEntry(target, metadata);\n    }\n  );\n}\n/**\n * @template T\n * @param {?} instance\n * @return {?}\n */\n\n\nfunction getEffectDecoratorMetadata(instance) {\n  /** @type {?} */\n  const effectsDecorators = compose(getEffectMetadataEntries, getSourceForInstance)(instance);\n  return effectsDecorators;\n}\n/**\n * Type guard to detemine whether METADATA_KEY is already present on the Class\n * constructor\n * @template T\n * @param {?} sourceProto\n * @return {?}\n */\n\n\nfunction hasMetadataEntries(sourceProto) {\n  return sourceProto.constructor.hasOwnProperty(METADATA_KEY);\n}\n/**\n * Add Effect Metadata to the Effect Class constructor under specific key\n * @template T\n * @param {?} sourceProto\n * @param {?} metadata\n * @return {?}\n */\n\n\nfunction addEffectMetadataEntry(sourceProto, metadata) {\n  if (hasMetadataEntries(sourceProto)) {\n    sourceProto.constructor[METADATA_KEY].push(metadata);\n  } else {\n    Object.defineProperty(sourceProto.constructor, METADATA_KEY, {\n      value: [metadata]\n    });\n  }\n}\n/**\n * @template T\n * @param {?} sourceProto\n * @return {?}\n */\n\n\nfunction getEffectMetadataEntries(sourceProto) {\n  return hasMetadataEntries(sourceProto) ? sourceProto.constructor[METADATA_KEY] : [];\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/effects_metadata.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n * @param {?} instance\n * @return {?}\n */\n\n\nfunction getEffectsMetadata(instance) {\n  return getSourceMetadata(instance).reduce(\n  /**\n  * @param {?} acc\n  * @param {?} __1\n  * @return {?}\n  */\n  (acc, {\n    propertyName,\n    dispatch,\n    useEffectsErrorHandler\n  }) => {\n    acc[propertyName] = {\n      dispatch,\n      useEffectsErrorHandler\n    };\n    return acc;\n  }, {});\n}\n/**\n * @template T\n * @param {?} instance\n * @return {?}\n */\n\n\nfunction getSourceMetadata(instance) {\n  /** @type {?} */\n  const effects = [getEffectDecoratorMetadata, getCreateEffectMetadata];\n  return effects.reduce(\n  /**\n  * @param {?} sources\n  * @param {?} source\n  * @return {?}\n  */\n  (sources, source) => sources.concat(source(instance)), []);\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/effects_resolver.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} sourceInstance\n * @param {?} globalErrorHandler\n * @param {?} effectsErrorHandler\n * @return {?}\n */\n\n\nfunction mergeEffects(sourceInstance, globalErrorHandler, effectsErrorHandler) {\n  /** @type {?} */\n  const sourceName = getSourceForInstance(sourceInstance).constructor.name;\n  /** @type {?} */\n\n  const observables$ = getSourceMetadata(sourceInstance).map(\n  /**\n  * @param {?} __0\n  * @return {?}\n  */\n  ({\n    propertyName,\n    dispatch,\n    useEffectsErrorHandler\n  }) => {\n    /** @type {?} */\n    const observable$ = typeof sourceInstance[propertyName] === 'function' ? sourceInstance[propertyName]() : sourceInstance[propertyName];\n    /** @type {?} */\n\n    const effectAction$ = useEffectsErrorHandler ? effectsErrorHandler(observable$, globalErrorHandler) : observable$;\n\n    if (dispatch === false) {\n      return effectAction$.pipe(ignoreElements());\n    }\n    /** @type {?} */\n\n\n    const materialized$ = effectAction$.pipe(materialize());\n    return materialized$.pipe(map(\n    /**\n    * @param {?} notification\n    * @return {?}\n    */\n    notification => ({\n      effect: sourceInstance[propertyName],\n      notification,\n      propertyName,\n      sourceName,\n      sourceInstance\n    })));\n  });\n  return merge(...observables$);\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/effects_error_handler.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst MAX_NUMBER_OF_RETRY_ATTEMPTS = 10;\n/**\n * @template T\n * @param {?} observable$\n * @param {?} errorHandler\n * @param {?=} retryAttemptLeft\n * @return {?}\n */\n\nfunction defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft = MAX_NUMBER_OF_RETRY_ATTEMPTS) {\n  return observable$.pipe(catchError(\n  /**\n  * @param {?} error\n  * @return {?}\n  */\n  error => {\n    if (errorHandler) errorHandler.handleError(error);\n\n    if (retryAttemptLeft <= 1) {\n      return observable$; // last attempt\n    } // Return observable that produces this particular effect\n\n\n    return defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft - 1);\n  }));\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/actions.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template V\n */\n\n\nlet Actions = /*#__PURE__*/(() => {\n  class Actions extends Observable {\n    /**\n     * @param {?=} source\n     */\n    constructor(source) {\n      super();\n\n      if (source) {\n        this.source = source;\n      }\n    }\n    /**\n     * @template R\n     * @param {?} operator\n     * @return {?}\n     */\n\n\n    lift(operator) {\n      /** @type {?} */\n      const observable = new Actions();\n      observable.source = this;\n      observable.operator = operator;\n      return observable;\n    }\n\n  }\n\n  Actions.ɵfac = function Actions_Factory(t) {\n    return new (t || Actions)(ɵngcc0.ɵɵinject(ScannedActionsSubject));\n  };\n\n  Actions.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: Actions,\n    factory: Actions.ɵfac\n  });\n  /** @nocollapse */\n\n  return Actions;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @param {...?} allowedTypes\n * @return {?}\n */\n\n\nfunction ofType(...allowedTypes) {\n  return filter(\n  /**\n  * @param {?} action\n  * @return {?}\n  */\n  action => allowedTypes.some(\n  /**\n  * @param {?} typeOrActionCreator\n  * @return {?}\n  */\n  typeOrActionCreator => {\n    if (typeof typeOrActionCreator === 'string') {\n      // Comparing the string to type\n      return typeOrActionCreator === action.type;\n    } // We are filtering by ActionCreator\n\n\n    return typeOrActionCreator.type === action.type;\n  }));\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/effect_notification.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction EffectNotification() {}\n\nif (false) {\n  /** @type {?} */\n  EffectNotification.prototype.effect;\n  /** @type {?} */\n\n  EffectNotification.prototype.propertyName;\n  /** @type {?} */\n\n  EffectNotification.prototype.sourceName;\n  /** @type {?} */\n\n  EffectNotification.prototype.sourceInstance;\n  /** @type {?} */\n\n  EffectNotification.prototype.notification;\n}\n/**\n * @param {?} output\n * @param {?} reporter\n * @return {?}\n */\n\n\nfunction reportInvalidActions(output, reporter) {\n  if (output.notification.kind === 'N') {\n    /** @type {?} */\n    const action = output.notification.value;\n    /** @type {?} */\n\n    const isInvalidAction = !isAction(action);\n\n    if (isInvalidAction) {\n      reporter.handleError(new Error(`Effect ${getEffectName(output)} dispatched an invalid action: ${stringify(action)}`));\n    }\n  }\n}\n/**\n * @param {?} action\n * @return {?}\n */\n\n\nfunction isAction(action) {\n  return typeof action !== 'function' && action && action.type && typeof action.type === 'string';\n}\n/**\n * @param {?} __0\n * @return {?}\n */\n\n\nfunction getEffectName({\n  propertyName,\n  sourceInstance,\n  sourceName\n}) {\n  /** @type {?} */\n  const isMethod = typeof sourceInstance[propertyName] === 'function';\n  return `\"${sourceName}.${String(propertyName)}${isMethod ? '()' : ''}\"`;\n}\n/**\n * @param {?} action\n * @return {?}\n */\n\n\nfunction stringify(action) {\n  try {\n    return JSON.stringify(action);\n  } catch (_a) {\n    return action;\n  }\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/lifecycle_hooks.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst onIdentifyEffectsKey = 'ngrxOnIdentifyEffects';\n/**\n * @param {?} instance\n * @return {?}\n */\n\nfunction isOnIdentifyEffects(instance) {\n  return isFunction(instance, onIdentifyEffectsKey);\n}\n/** @type {?} */\n\n\nconst onRunEffectsKey = 'ngrxOnRunEffects';\n/**\n * @param {?} instance\n * @return {?}\n */\n\nfunction isOnRunEffects(instance) {\n  return isFunction(instance, onRunEffectsKey);\n}\n/** @type {?} */\n\n\nconst onInitEffects = 'ngrxOnInitEffects';\n/**\n * @param {?} instance\n * @return {?}\n */\n\nfunction isOnInitEffects(instance) {\n  return isFunction(instance, onInitEffects);\n}\n/**\n * @param {?} instance\n * @param {?} functionName\n * @return {?}\n */\n\n\nfunction isFunction(instance, functionName) {\n  return instance && functionName in instance && typeof instance[functionName] === 'function';\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/tokens.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst _ROOT_EFFECTS_GUARD = new InjectionToken('@ngrx/effects Internal Root Guard');\n/** @type {?} */\n\n\nconst IMMEDIATE_EFFECTS = new InjectionToken('ngrx/effects: Immediate Effects');\n/** @type {?} */\n\nconst USER_PROVIDED_EFFECTS = new InjectionToken('ngrx/effects: User Provided Effects');\n/** @type {?} */\n\nconst _ROOT_EFFECTS = new InjectionToken('ngrx/effects: Internal Root Effects');\n/** @type {?} */\n\n\nconst ROOT_EFFECTS = new InjectionToken('ngrx/effects: Root Effects');\n/** @type {?} */\n\nconst _FEATURE_EFFECTS = new InjectionToken('ngrx/effects: Internal Feature Effects');\n/** @type {?} */\n\n\nconst FEATURE_EFFECTS = new InjectionToken('ngrx/effects: Feature Effects');\n/** @type {?} */\n\nconst EFFECTS_ERROR_HANDLER = new InjectionToken('ngrx/effects: Effects Error Handler');\n/**\n * @fileoverview added by tsickle\n * Generated from: src/effect_sources.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nlet EffectSources = /*#__PURE__*/(() => {\n  class EffectSources extends Subject {\n    /**\n     * @param {?} errorHandler\n     * @param {?} effectsErrorHandler\n     */\n    constructor(errorHandler, effectsErrorHandler) {\n      super();\n      this.errorHandler = errorHandler;\n      this.effectsErrorHandler = effectsErrorHandler;\n    }\n    /**\n     * @param {?} effectSourceInstance\n     * @return {?}\n     */\n\n\n    addEffects(effectSourceInstance) {\n      this.next(effectSourceInstance);\n    }\n    /**\n     * \\@internal\n     * @return {?}\n     */\n\n\n    toActions() {\n      return this.pipe(groupBy(getSourceForInstance), mergeMap(\n      /**\n      * @param {?} source$\n      * @return {?}\n      */\n      source$ => {\n        return source$.pipe(groupBy(effectsInstance));\n      }), mergeMap(\n      /**\n      * @param {?} source$\n      * @return {?}\n      */\n      source$ => {\n        /** @type {?} */\n        const effect$ = source$.pipe(exhaustMap(\n        /**\n        * @param {?} sourceInstance\n        * @return {?}\n        */\n        sourceInstance => {\n          return resolveEffectSource(this.errorHandler, this.effectsErrorHandler)(sourceInstance);\n        }), map(\n        /**\n        * @param {?} output\n        * @return {?}\n        */\n        output => {\n          reportInvalidActions(output, this.errorHandler);\n          return output.notification;\n        }), filter(\n        /**\n        * @param {?} notification\n        * @return {?}\n        */\n        notification => notification.kind === 'N'), dematerialize()); // start the stream with an INIT action\n        // do this only for the first Effect instance\n\n        /** @type {?} */\n\n        const init$ = source$.pipe(take(1), filter(isOnInitEffects), map(\n        /**\n        * @param {?} instance\n        * @return {?}\n        */\n        instance => instance.ngrxOnInitEffects()));\n        return merge(effect$, init$);\n      }));\n    }\n\n  }\n\n  EffectSources.ɵfac = function EffectSources_Factory(t) {\n    return new (t || EffectSources)(ɵngcc0.ɵɵinject(ɵngcc0.ErrorHandler), ɵngcc0.ɵɵinject(EFFECTS_ERROR_HANDLER));\n  };\n\n  EffectSources.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: EffectSources,\n    factory: EffectSources.ɵfac\n  });\n  /** @nocollapse */\n\n  return EffectSources;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  EffectSources.prototype.errorHandler;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  EffectSources.prototype.effectsErrorHandler;\n}\n/**\n * @param {?} sourceInstance\n * @return {?}\n */\n\n\nfunction effectsInstance(sourceInstance) {\n  if (isOnIdentifyEffects(sourceInstance)) {\n    return sourceInstance.ngrxOnIdentifyEffects();\n  }\n\n  return '';\n}\n/**\n * @param {?} errorHandler\n * @param {?} effectsErrorHandler\n * @return {?}\n */\n\n\nfunction resolveEffectSource(errorHandler, effectsErrorHandler) {\n  return (\n    /**\n    * @param {?} sourceInstance\n    * @return {?}\n    */\n    sourceInstance => {\n      /** @type {?} */\n      const mergedEffects$ = mergeEffects(sourceInstance, errorHandler, effectsErrorHandler);\n\n      if (isOnRunEffects(sourceInstance)) {\n        return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n      }\n\n      return mergedEffects$;\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/effects_runner.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet EffectsRunner = /*#__PURE__*/(() => {\n  class EffectsRunner {\n    /**\n     * @param {?} effectSources\n     * @param {?} store\n     */\n    constructor(effectSources, store) {\n      this.effectSources = effectSources;\n      this.store = store;\n      this.effectsSubscription = null;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    start() {\n      if (!this.effectsSubscription) {\n        this.effectsSubscription = this.effectSources.toActions().subscribe(this.store);\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      if (this.effectsSubscription) {\n        this.effectsSubscription.unsubscribe();\n        this.effectsSubscription = null;\n      }\n    }\n\n  }\n\n  EffectsRunner.ɵfac = function EffectsRunner_Factory(t) {\n    return new (t || EffectsRunner)(ɵngcc0.ɵɵinject(EffectSources), ɵngcc0.ɵɵinject(ɵngcc2.Store));\n  };\n\n  EffectsRunner.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: EffectsRunner,\n    factory: EffectsRunner.ɵfac\n  });\n  /** @nocollapse */\n\n  return EffectsRunner;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  EffectsRunner.prototype.effectsSubscription;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  EffectsRunner.prototype.effectSources;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  EffectsRunner.prototype.store;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/effects_root_module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst ROOT_EFFECTS_INIT = '@ngrx/effects/init';\n/** @type {?} */\n\nconst rootEffectsInit = createAction(ROOT_EFFECTS_INIT);\nlet EffectsRootModule = /*#__PURE__*/(() => {\n  class EffectsRootModule {\n    /**\n     * @param {?} sources\n     * @param {?} runner\n     * @param {?} store\n     * @param {?} rootEffects\n     * @param {?} storeRootModule\n     * @param {?} storeFeatureModule\n     * @param {?} guard\n     */\n    constructor(sources, runner, store, rootEffects, storeRootModule, storeFeatureModule, guard) {\n      this.sources = sources;\n      runner.start();\n      rootEffects.forEach(\n      /**\n      * @param {?} effectSourceInstance\n      * @return {?}\n      */\n      effectSourceInstance => sources.addEffects(effectSourceInstance));\n      store.dispatch({\n        type: ROOT_EFFECTS_INIT\n      });\n    }\n    /**\n     * @param {?} effectSourceInstance\n     * @return {?}\n     */\n\n\n    addEffects(effectSourceInstance) {\n      this.sources.addEffects(effectSourceInstance);\n    }\n\n  }\n\n  EffectsRootModule.ɵfac = function EffectsRootModule_Factory(t) {\n    return new (t || EffectsRootModule)(ɵngcc0.ɵɵinject(EffectSources), ɵngcc0.ɵɵinject(EffectsRunner), ɵngcc0.ɵɵinject(ɵngcc2.Store), ɵngcc0.ɵɵinject(ROOT_EFFECTS), ɵngcc0.ɵɵinject(ɵngcc2.StoreRootModule, 8), ɵngcc0.ɵɵinject(ɵngcc2.StoreFeatureModule, 8), ɵngcc0.ɵɵinject(_ROOT_EFFECTS_GUARD, 8));\n  };\n\n  EffectsRootModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: EffectsRootModule\n  });\n  EffectsRootModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  /** @nocollapse */\n\n  return EffectsRootModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  EffectsRootModule.prototype.sources;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/effects_feature_module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet EffectsFeatureModule = /*#__PURE__*/(() => {\n  class EffectsFeatureModule {\n    /**\n     * @param {?} root\n     * @param {?} effectSourceGroups\n     * @param {?} storeRootModule\n     * @param {?} storeFeatureModule\n     */\n    constructor(root, effectSourceGroups, storeRootModule, storeFeatureModule) {\n      effectSourceGroups.forEach(\n      /**\n      * @param {?} group\n      * @return {?}\n      */\n      group => group.forEach(\n      /**\n      * @param {?} effectSourceInstance\n      * @return {?}\n      */\n      effectSourceInstance => root.addEffects(effectSourceInstance)));\n    }\n\n  }\n\n  EffectsFeatureModule.ɵfac = function EffectsFeatureModule_Factory(t) {\n    return new (t || EffectsFeatureModule)(ɵngcc0.ɵɵinject(EffectsRootModule), ɵngcc0.ɵɵinject(FEATURE_EFFECTS), ɵngcc0.ɵɵinject(ɵngcc2.StoreRootModule, 8), ɵngcc0.ɵɵinject(ɵngcc2.StoreFeatureModule, 8));\n  };\n\n  EffectsFeatureModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: EffectsFeatureModule\n  });\n  EffectsFeatureModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  /** @nocollapse */\n\n  return EffectsFeatureModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: src/effects_module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet EffectsModule = /*#__PURE__*/(() => {\n  class EffectsModule {\n    /**\n     * @param {?=} featureEffects\n     * @return {?}\n     */\n    static forFeature(featureEffects = []) {\n      return {\n        ngModule: EffectsFeatureModule,\n        providers: [featureEffects, {\n          provide: _FEATURE_EFFECTS,\n          multi: true,\n          useValue: featureEffects\n        }, {\n          provide: USER_PROVIDED_EFFECTS,\n          multi: true,\n          useValue: []\n        }, {\n          provide: FEATURE_EFFECTS,\n          multi: true,\n          useFactory: createEffects,\n          deps: [Injector, _FEATURE_EFFECTS, USER_PROVIDED_EFFECTS]\n        }]\n      };\n    }\n    /**\n     * @param {?=} rootEffects\n     * @return {?}\n     */\n\n\n    static forRoot(rootEffects = []) {\n      return {\n        ngModule: EffectsRootModule,\n        providers: [{\n          provide: EFFECTS_ERROR_HANDLER,\n          useValue: defaultEffectsErrorHandler\n        }, EffectsRunner, EffectSources, Actions, rootEffects, {\n          provide: _ROOT_EFFECTS,\n          useValue: [rootEffects]\n        }, {\n          provide: _ROOT_EFFECTS_GUARD,\n          useFactory: _provideForRootGuard,\n          deps: [[EffectsRunner, new Optional(), new SkipSelf()], [_ROOT_EFFECTS, new Self()]]\n        }, {\n          provide: USER_PROVIDED_EFFECTS,\n          multi: true,\n          useValue: []\n        }, {\n          provide: ROOT_EFFECTS,\n          useFactory: createEffects,\n          deps: [Injector, _ROOT_EFFECTS, USER_PROVIDED_EFFECTS]\n        }]\n      };\n    }\n\n  }\n\n  EffectsModule.ɵfac = function EffectsModule_Factory(t) {\n    return new (t || EffectsModule)();\n  };\n\n  EffectsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: EffectsModule\n  });\n  EffectsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return EffectsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @param {?} injector\n * @param {?} effectGroups\n * @param {?} userProvidedEffectGroups\n * @return {?}\n */\n\n\nfunction createEffects(injector, effectGroups, userProvidedEffectGroups) {\n  /** @type {?} */\n  const mergedEffects = [];\n\n  for (let effectGroup of effectGroups) {\n    mergedEffects.push(...effectGroup);\n  }\n\n  for (let userProvidedEffectGroup of userProvidedEffectGroups) {\n    mergedEffects.push(...userProvidedEffectGroup);\n  }\n\n  return createEffectInstances(injector, mergedEffects);\n}\n/**\n * @param {?} injector\n * @param {?} effects\n * @return {?}\n */\n\n\nfunction createEffectInstances(injector, effects) {\n  return effects.map(\n  /**\n  * @param {?} effect\n  * @return {?}\n  */\n  effect => injector.get(effect));\n}\n/**\n * @param {?} runner\n * @param {?} rootEffects\n * @return {?}\n */\n\n\nfunction _provideForRootGuard(runner, rootEffects) {\n  // check whether any effects are actually passed\n\n  /** @type {?} */\n  const hasEffects = !(rootEffects.length === 1 && rootEffects[0].length === 0);\n\n  if (hasEffects && runner) {\n    throw new TypeError(`EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.`);\n  }\n\n  return 'guarded';\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/act.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Represents config with named paratemeters for act\n * @record\n * @template Input, OutputAction, ErrorAction, CompleteAction, UnsubscribeAction\n */\n\n\nfunction ActConfig() {}\n\nif (false) {\n  /** @type {?} */\n  ActConfig.prototype.project;\n  /** @type {?} */\n\n  ActConfig.prototype.error;\n  /** @type {?|undefined} */\n\n  ActConfig.prototype.complete;\n  /** @type {?|undefined} */\n\n  ActConfig.prototype.operator;\n  /** @type {?|undefined} */\n\n  ActConfig.prototype.unsubscribe;\n}\n/**\n * @template Input, OutputAction, ErrorAction, CompleteAction, UnsubscribeAction\n * @param {?} configOrProject\n * @param {?=} errorFn\n * @return {?}\n */\n\n\nfunction act(\n/** Allow to take either config object or project/error functions */\nconfigOrProject, errorFn) {\n  const {\n    project,\n    error,\n    complete,\n    operator,\n    unsubscribe\n  } = typeof configOrProject === 'function' ? {\n    project: configOrProject,\n    error:\n    /** @type {?} */\n    errorFn,\n    operator: concatMap,\n    complete: undefined,\n    unsubscribe: undefined\n  } : Object.assign(Object.assign({}, configOrProject), {\n    operator: configOrProject.operator || concatMap\n  });\n  return (\n    /**\n    * @param {?} source\n    * @return {?}\n    */\n    source => defer(\n    /**\n    * @return {?}\n    */\n    () => {\n      /** @type {?} */\n      const subject = new Subject();\n      return merge(source.pipe(operator(\n      /**\n      * @param {?} input\n      * @param {?} index\n      * @return {?}\n      */\n      (input, index) => defer(\n      /**\n      * @return {?}\n      */\n      () => {\n        /** @type {?} */\n        let completed = false;\n        /** @type {?} */\n\n        let errored = false;\n        /** @type {?} */\n\n        let projectedCount = 0;\n        return project(input, index).pipe(materialize(), map(\n        /**\n        * @param {?} notification\n        * @return {?}\n        */\n        notification => {\n          switch (notification.kind) {\n            case 'E':\n              errored = true;\n              return new Notification(\n              /** @type {?} */\n              // TODO: remove any in RxJS 6.5\n              'N', error(notification.error, input));\n\n            case 'C':\n              completed = true;\n              return complete ? new Notification(\n              /** @type {?} */\n              // TODO: remove any in RxJS 6.5\n              'N', complete(projectedCount, input)) : undefined;\n\n            default:\n              ++projectedCount;\n              return notification;\n          }\n        }), filter(\n        /**\n        * @param {?} n\n        * @return {?}\n        */\n        n => n != null), dematerialize(), finalize(\n        /**\n        * @return {?}\n        */\n        () => {\n          if (!completed && !errored && unsubscribe) {\n            subject.next(unsubscribe(projectedCount, input));\n          }\n        }));\n      }))), subject);\n    })\n  );\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: ngrx-effects.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { Actions, EFFECTS_ERROR_HANDLER, Effect, EffectSources, EffectsFeatureModule, EffectsModule, EffectsRootModule, EffectsRunner, ROOT_EFFECTS_INIT, USER_PROVIDED_EFFECTS, act, createEffect, defaultEffectsErrorHandler, getEffectsMetadata, mergeEffects, ofType, rootEffectsInit, getSourceMetadata as ɵa, createEffects as ɵb, _provideForRootGuard as ɵc, _ROOT_EFFECTS_GUARD as ɵd, _ROOT_EFFECTS as ɵe, ROOT_EFFECTS as ɵf, _FEATURE_EFFECTS as ɵg, FEATURE_EFFECTS as ɵh }; //# sourceMappingURL=ngrx-effects.js.map","map":null,"metadata":{},"sourceType":"module"}