{"ast":null,"code":"(function (global, factory) {\n  typeof exports === \"object\" && typeof module !== \"undefined\" ? module.exports = factory(require(\"nearest-periodic-value\")) : typeof define === \"function\" && define.amd ? define([\"nearest-periodic-value\"], factory) : global.containedPeriodicValues = factory(global.nearestPeriodicValue);\n})(this, function (nearestPeriodicValue) {\n  \"use strict\";\n\n  function containedPeriodicValues(start, end, value, period) {\n    // Inclusive start; exclusive end\n    if (start === end) {\n      return 0;\n    } // Flip our interval if it isn't ordered properly\n\n\n    if (start > end) {\n      var newEnd = start;\n      start = end;\n      end = newEnd;\n    } // Make our interval have an exclusive end\n\n\n    end--;\n    var nearest = nearestPeriodicValue(start, value, period); // Ensure that the nearest value is in front of the start\n    // of the interval\n\n    if (nearest - start < 0) {\n      nearest += period;\n    } // If we can't even reach the first value, then it is 0\n\n\n    if (nearest - start > end - start) {\n      return 0;\n    } // Otherwise, we have reached it, so we start with 1.\n    // Then we add one for every full period in our interval\n    else {\n      return 1 + parseInt((end - nearest) / period);\n    }\n  }\n\n  var contained_periodic_values = containedPeriodicValues;\n  return contained_periodic_values;\n}); //# sourceMappingURL=./contained-periodic-values.js.map","map":null,"metadata":{},"sourceType":"script"}