{"ast":null,"code":"import { InjectionToken, Injectable, Inject, ErrorHandler, NgModule } from '@angular/core';\nimport { ActionsSubject, UPDATE, INIT, ReducerObservable, ScannedActionsSubject, INITIAL_STATE, StateObservable, ReducerManagerDispatcher } from '@ngrx/store';\nimport { empty, Observable, of, merge, queueScheduler, ReplaySubject } from 'rxjs';\nimport { share, filter, map, concatMap, timeout, debounceTime, catchError, take, takeUntil, switchMap, skip, observeOn, withLatestFrom, scan } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * Generated from: src/config.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@ngrx/store';\n\nfunction DevToolsFeatureOptions() {}\n\nif (false) {\n  /** @type {?|undefined} */\n  DevToolsFeatureOptions.prototype.pause;\n  /** @type {?|undefined} */\n\n  DevToolsFeatureOptions.prototype.lock;\n  /** @type {?|undefined} */\n\n  DevToolsFeatureOptions.prototype.persist;\n  /** @type {?|undefined} */\n\n  DevToolsFeatureOptions.prototype.export;\n  /** @type {?|undefined} */\n\n  DevToolsFeatureOptions.prototype.import;\n  /** @type {?|undefined} */\n\n  DevToolsFeatureOptions.prototype.jump;\n  /** @type {?|undefined} */\n\n  DevToolsFeatureOptions.prototype.skip;\n  /** @type {?|undefined} */\n\n  DevToolsFeatureOptions.prototype.reorder;\n  /** @type {?|undefined} */\n\n  DevToolsFeatureOptions.prototype.dispatch;\n  /** @type {?|undefined} */\n\n  DevToolsFeatureOptions.prototype.test;\n}\n\nclass StoreDevtoolsConfig {\n  constructor() {\n    this.maxAge = false;\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  StoreDevtoolsConfig.prototype.maxAge;\n  /** @type {?} */\n\n  StoreDevtoolsConfig.prototype.monitor;\n  /** @type {?} */\n\n  StoreDevtoolsConfig.prototype.actionSanitizer;\n  /** @type {?} */\n\n  StoreDevtoolsConfig.prototype.stateSanitizer;\n  /** @type {?} */\n\n  StoreDevtoolsConfig.prototype.name;\n  /** @type {?} */\n\n  StoreDevtoolsConfig.prototype.serialize;\n  /** @type {?} */\n\n  StoreDevtoolsConfig.prototype.logOnly;\n  /** @type {?} */\n\n  StoreDevtoolsConfig.prototype.features;\n  /** @type {?} */\n\n  StoreDevtoolsConfig.prototype.actionsBlocklist;\n  /** @type {?} */\n\n  StoreDevtoolsConfig.prototype.actionsSafelist;\n  /** @type {?} */\n\n  StoreDevtoolsConfig.prototype.predicate;\n}\n/** @type {?} */\n\n\nconst STORE_DEVTOOLS_CONFIG = new InjectionToken('@ngrx/devtools Options');\n/** @type {?} */\n\nconst INITIAL_OPTIONS = new InjectionToken('@ngrx/devtools Initial Config');\n/**\n * @return {?}\n */\n\nfunction noMonitor() {\n  return null;\n}\n/** @type {?} */\n\n\nconst DEFAULT_NAME = 'NgRx Store DevTools';\n/**\n * @param {?} _options\n * @return {?}\n */\n\nfunction createConfig(_options) {\n  /** @type {?} */\n  const DEFAULT_OPTIONS = {\n    maxAge: false,\n    monitor: noMonitor,\n    actionSanitizer: undefined,\n    stateSanitizer: undefined,\n    name: DEFAULT_NAME,\n    serialize: false,\n    logOnly: false,\n    // Add all features explicitly. This prevent buggy behavior for\n    // options like \"lock\" which might otherwise not show up.\n    features: {\n      pause: true,\n      // start/pause recording of dispatched actions\n      lock: true,\n      // lock/unlock dispatching actions and side effects\n      persist: true,\n      // persist states on page reloading\n      export: true,\n      // export history of actions in a file\n      import: 'custom',\n      // import history of actions from a file\n      jump: true,\n      // jump back and forth (time travelling)\n      skip: true,\n      // skip (cancel) actions\n      reorder: true,\n      // drag and drop actions in the history list\n      dispatch: true,\n      // dispatch custom actions or action creators\n      test: true\n    }\n  };\n  /** @type {?} */\n\n  let options = typeof _options === 'function' ? _options() : _options;\n  /** @type {?} */\n\n  const logOnly = options.logOnly ? {\n    pause: true,\n    export: true,\n    test: true\n  } : false;\n  /** @type {?} */\n\n  const features = options.features || logOnly || DEFAULT_OPTIONS.features;\n  /** @type {?} */\n\n  const config = Object.assign({}, DEFAULT_OPTIONS, {\n    features\n  }, options);\n\n  if (config.maxAge && config.maxAge < 2) {\n    throw new Error(`Devtools 'maxAge' cannot be less than 2, got ${config.maxAge}`);\n  }\n\n  return config;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/actions.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst PERFORM_ACTION = 'PERFORM_ACTION';\n/** @type {?} */\n\nconst REFRESH = 'REFRESH';\n/** @type {?} */\n\nconst RESET = 'RESET';\n/** @type {?} */\n\nconst ROLLBACK = 'ROLLBACK';\n/** @type {?} */\n\nconst COMMIT = 'COMMIT';\n/** @type {?} */\n\nconst SWEEP = 'SWEEP';\n/** @type {?} */\n\nconst TOGGLE_ACTION = 'TOGGLE_ACTION';\n/** @type {?} */\n\nconst SET_ACTIONS_ACTIVE = 'SET_ACTIONS_ACTIVE';\n/** @type {?} */\n\nconst JUMP_TO_STATE = 'JUMP_TO_STATE';\n/** @type {?} */\n\nconst JUMP_TO_ACTION = 'JUMP_TO_ACTION';\n/** @type {?} */\n\nconst IMPORT_STATE = 'IMPORT_STATE';\n/** @type {?} */\n\nconst LOCK_CHANGES = 'LOCK_CHANGES';\n/** @type {?} */\n\nconst PAUSE_RECORDING = 'PAUSE_RECORDING';\n\nclass PerformAction {\n  /**\n   * @param {?} action\n   * @param {?} timestamp\n   */\n  constructor(action, timestamp) {\n    this.action = action;\n    this.timestamp = timestamp;\n    this.type = PERFORM_ACTION;\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  PerformAction.prototype.type;\n  /** @type {?} */\n\n  PerformAction.prototype.action;\n  /** @type {?} */\n\n  PerformAction.prototype.timestamp;\n}\n\nclass Refresh {\n  constructor() {\n    this.type = REFRESH;\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  Refresh.prototype.type;\n}\n\nclass Reset {\n  /**\n   * @param {?} timestamp\n   */\n  constructor(timestamp) {\n    this.timestamp = timestamp;\n    this.type = RESET;\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  Reset.prototype.type;\n  /** @type {?} */\n\n  Reset.prototype.timestamp;\n}\n\nclass Rollback {\n  /**\n   * @param {?} timestamp\n   */\n  constructor(timestamp) {\n    this.timestamp = timestamp;\n    this.type = ROLLBACK;\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  Rollback.prototype.type;\n  /** @type {?} */\n\n  Rollback.prototype.timestamp;\n}\n\nclass Commit {\n  /**\n   * @param {?} timestamp\n   */\n  constructor(timestamp) {\n    this.timestamp = timestamp;\n    this.type = COMMIT;\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  Commit.prototype.type;\n  /** @type {?} */\n\n  Commit.prototype.timestamp;\n}\n\nclass Sweep {\n  constructor() {\n    this.type = SWEEP;\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  Sweep.prototype.type;\n}\n\nclass ToggleAction {\n  /**\n   * @param {?} id\n   */\n  constructor(id) {\n    this.id = id;\n    this.type = TOGGLE_ACTION;\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  ToggleAction.prototype.type;\n  /** @type {?} */\n\n  ToggleAction.prototype.id;\n}\n\nclass SetActionsActive {\n  /**\n   * @param {?} start\n   * @param {?} end\n   * @param {?=} active\n   */\n  constructor(start, end, active = true) {\n    this.start = start;\n    this.end = end;\n    this.active = active;\n    this.type = SET_ACTIONS_ACTIVE;\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  SetActionsActive.prototype.type;\n  /** @type {?} */\n\n  SetActionsActive.prototype.start;\n  /** @type {?} */\n\n  SetActionsActive.prototype.end;\n  /** @type {?} */\n\n  SetActionsActive.prototype.active;\n}\n\nclass JumpToState {\n  /**\n   * @param {?} index\n   */\n  constructor(index) {\n    this.index = index;\n    this.type = JUMP_TO_STATE;\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  JumpToState.prototype.type;\n  /** @type {?} */\n\n  JumpToState.prototype.index;\n}\n\nclass JumpToAction {\n  /**\n   * @param {?} actionId\n   */\n  constructor(actionId) {\n    this.actionId = actionId;\n    this.type = JUMP_TO_ACTION;\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  JumpToAction.prototype.type;\n  /** @type {?} */\n\n  JumpToAction.prototype.actionId;\n}\n\nclass ImportState {\n  /**\n   * @param {?} nextLiftedState\n   */\n  constructor(nextLiftedState) {\n    this.nextLiftedState = nextLiftedState;\n    this.type = IMPORT_STATE;\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  ImportState.prototype.type;\n  /** @type {?} */\n\n  ImportState.prototype.nextLiftedState;\n}\n\nclass LockChanges {\n  /**\n   * @param {?} status\n   */\n  constructor(status) {\n    this.status = status;\n    this.type = LOCK_CHANGES;\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  LockChanges.prototype.type;\n  /** @type {?} */\n\n  LockChanges.prototype.status;\n}\n\nclass PauseRecording {\n  /**\n   * @param {?} status\n   */\n  constructor(status) {\n    this.status = status;\n    this.type = PAUSE_RECORDING;\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  PauseRecording.prototype.type;\n  /** @type {?} */\n\n  PauseRecording.prototype.status;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/devtools-dispatcher.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet DevtoolsDispatcher = /*#__PURE__*/(() => {\n  class DevtoolsDispatcher extends ActionsSubject {}\n\n  DevtoolsDispatcher.ɵfac = /*@__PURE__*/function () {\n    let ɵDevtoolsDispatcher_BaseFactory;\n    return function DevtoolsDispatcher_Factory(t) {\n      return (ɵDevtoolsDispatcher_BaseFactory || (ɵDevtoolsDispatcher_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(DevtoolsDispatcher)))(t || DevtoolsDispatcher);\n    };\n  }();\n\n  DevtoolsDispatcher.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: DevtoolsDispatcher,\n    factory: DevtoolsDispatcher.ɵfac\n  });\n  return DevtoolsDispatcher;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: src/utils.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} first\n * @param {?} second\n * @return {?}\n */\n\n\nfunction difference(first, second) {\n  return first.filter(\n  /**\n  * @param {?} item\n  * @return {?}\n  */\n  item => second.indexOf(item) < 0);\n}\n/**\n * Provides an app's view into the state of the lifted store.\n * @param {?} liftedState\n * @return {?}\n */\n\n\nfunction unliftState(liftedState) {\n  const {\n    computedStates,\n    currentStateIndex\n  } = liftedState; // At start up NgRx dispatches init actions,\n  // When these init actions are being filtered out by the predicate or safe/block list options\n  // we don't have a complete computed states yet.\n  // At this point it could happen that we're out of bounds, when this happens we fall back to the last known state\n\n  if (currentStateIndex >= computedStates.length) {\n    const {\n      state\n    } = computedStates[computedStates.length - 1];\n    return state;\n  }\n\n  const {\n    state\n  } = computedStates[currentStateIndex];\n  return state;\n}\n/**\n * @param {?} liftedState\n * @return {?}\n */\n\n\nfunction unliftAction(liftedState) {\n  return liftedState.actionsById[liftedState.nextActionId - 1];\n}\n/**\n * Lifts an app's action into an action on the lifted store.\n * @param {?} action\n * @return {?}\n */\n\n\nfunction liftAction(action) {\n  return new PerformAction(action, +Date.now());\n}\n/**\n * Sanitizes given actions with given function.\n * @param {?} actionSanitizer\n * @param {?} actions\n * @return {?}\n */\n\n\nfunction sanitizeActions(actionSanitizer, actions) {\n  return Object.keys(actions).reduce(\n  /**\n  * @param {?} sanitizedActions\n  * @param {?} actionIdx\n  * @return {?}\n  */\n  (sanitizedActions, actionIdx) => {\n    /** @type {?} */\n    const idx = Number(actionIdx);\n    sanitizedActions[idx] = sanitizeAction(actionSanitizer, actions[idx], idx);\n    return sanitizedActions;\n  },\n  /** @type {?} */\n  {});\n}\n/**\n * Sanitizes given action with given function.\n * @param {?} actionSanitizer\n * @param {?} action\n * @param {?} actionIdx\n * @return {?}\n */\n\n\nfunction sanitizeAction(actionSanitizer, action, actionIdx) {\n  return Object.assign(Object.assign({}, action), {\n    action: actionSanitizer(action.action, actionIdx)\n  });\n}\n/**\n * Sanitizes given states with given function.\n * @param {?} stateSanitizer\n * @param {?} states\n * @return {?}\n */\n\n\nfunction sanitizeStates(stateSanitizer, states) {\n  return states.map(\n  /**\n  * @param {?} computedState\n  * @param {?} idx\n  * @return {?}\n  */\n  (computedState, idx) => ({\n    state: sanitizeState(stateSanitizer, computedState.state, idx),\n    error: computedState.error\n  }));\n}\n/**\n * Sanitizes given state with given function.\n * @param {?} stateSanitizer\n * @param {?} state\n * @param {?} stateIdx\n * @return {?}\n */\n\n\nfunction sanitizeState(stateSanitizer, state, stateIdx) {\n  return stateSanitizer(state, stateIdx);\n}\n/**\n * Read the config and tell if actions should be filtered\n * @param {?} config\n * @return {?}\n */\n\n\nfunction shouldFilterActions(config) {\n  return config.predicate || config.actionsSafelist || config.actionsBlocklist;\n}\n/**\n * Return a full filtered lifted state\n * @param {?} liftedState\n * @param {?=} predicate\n * @param {?=} safelist\n * @param {?=} blocklist\n * @return {?}\n */\n\n\nfunction filterLiftedState(liftedState, predicate, safelist, blocklist) {\n  /** @type {?} */\n  const filteredStagedActionIds = [];\n  /** @type {?} */\n\n  const filteredActionsById = {};\n  /** @type {?} */\n\n  const filteredComputedStates = [];\n  liftedState.stagedActionIds.forEach(\n  /**\n  * @param {?} id\n  * @param {?} idx\n  * @return {?}\n  */\n  (id, idx) => {\n    /** @type {?} */\n    const liftedAction = liftedState.actionsById[id];\n    if (!liftedAction) return;\n\n    if (idx && isActionFiltered(liftedState.computedStates[idx], liftedAction, predicate, safelist, blocklist)) {\n      return;\n    }\n\n    filteredActionsById[id] = liftedAction;\n    filteredStagedActionIds.push(id);\n    filteredComputedStates.push(liftedState.computedStates[idx]);\n  });\n  return Object.assign(Object.assign({}, liftedState), {\n    stagedActionIds: filteredStagedActionIds,\n    actionsById: filteredActionsById,\n    computedStates: filteredComputedStates\n  });\n}\n/**\n * Return true is the action should be ignored\n * @param {?} state\n * @param {?} action\n * @param {?=} predicate\n * @param {?=} safelist\n * @param {?=} blockedlist\n * @return {?}\n */\n\n\nfunction isActionFiltered(state, action, predicate, safelist, blockedlist) {\n  /** @type {?} */\n  const predicateMatch = predicate && !predicate(state, action.action);\n  /** @type {?} */\n\n  const safelistMatch = safelist && !action.action.type.match(safelist.map(\n  /**\n  * @param {?} s\n  * @return {?}\n  */\n  s => escapeRegExp(s)).join('|'));\n  /** @type {?} */\n\n  const blocklistMatch = blockedlist && action.action.type.match(blockedlist.map(\n  /**\n  * @param {?} s\n  * @return {?}\n  */\n  s => escapeRegExp(s)).join('|'));\n  return predicateMatch || safelistMatch || blocklistMatch;\n}\n/**\n * Return string with escaped RegExp special characters\n * https://stackoverflow.com/a/6969486/1337347\n * @param {?} s\n * @return {?}\n */\n\n\nfunction escapeRegExp(s) {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/extension.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst ExtensionActionTypes = {\n  START: 'START',\n  DISPATCH: 'DISPATCH',\n  STOP: 'STOP',\n  ACTION: 'ACTION'\n};\n/** @type {?} */\n\nconst REDUX_DEVTOOLS_EXTENSION = new InjectionToken('Redux Devtools Extension');\n/**\n * @record\n */\n\nfunction ReduxDevtoolsExtensionConnection() {}\n\nif (false) {\n  /**\n   * @param {?} listener\n   * @return {?}\n   */\n  ReduxDevtoolsExtensionConnection.prototype.subscribe = function (listener) {};\n  /**\n   * @return {?}\n   */\n\n\n  ReduxDevtoolsExtensionConnection.prototype.unsubscribe = function () {};\n  /**\n   * @param {?} action\n   * @param {?} state\n   * @return {?}\n   */\n\n\n  ReduxDevtoolsExtensionConnection.prototype.send = function (action, state) {};\n  /**\n   * @param {?=} state\n   * @return {?}\n   */\n\n\n  ReduxDevtoolsExtensionConnection.prototype.init = function (state) {};\n  /**\n   * @param {?} anyErr\n   * @return {?}\n   */\n\n\n  ReduxDevtoolsExtensionConnection.prototype.error = function (anyErr) {};\n}\n/**\n * @record\n */\n\n\nfunction ReduxDevtoolsExtensionConfig() {}\n\nif (false) {\n  /** @type {?|undefined} */\n  ReduxDevtoolsExtensionConfig.prototype.features;\n  /** @type {?} */\n\n  ReduxDevtoolsExtensionConfig.prototype.name;\n  /** @type {?|undefined} */\n\n  ReduxDevtoolsExtensionConfig.prototype.maxAge;\n  /** @type {?|undefined} */\n\n  ReduxDevtoolsExtensionConfig.prototype.serialize;\n}\n/**\n * @record\n */\n\n\nfunction ReduxDevtoolsExtension() {}\n\nif (false) {\n  /**\n   * @param {?} options\n   * @return {?}\n   */\n  ReduxDevtoolsExtension.prototype.connect = function (options) {};\n  /**\n   * @param {?} action\n   * @param {?} state\n   * @param {?} options\n   * @return {?}\n   */\n\n\n  ReduxDevtoolsExtension.prototype.send = function (action, state, options) {};\n}\n\nlet DevtoolsExtension = /*#__PURE__*/(() => {\n  class DevtoolsExtension {\n    /**\n     * @param {?} devtoolsExtension\n     * @param {?} config\n     * @param {?} dispatcher\n     */\n    constructor(devtoolsExtension, config, dispatcher) {\n      this.config = config;\n      this.dispatcher = dispatcher;\n      this.devtoolsExtension = devtoolsExtension;\n      this.createActionStreams();\n    }\n    /**\n     * @param {?} action\n     * @param {?} state\n     * @return {?}\n     */\n\n\n    notify(action, state) {\n      if (!this.devtoolsExtension) {\n        return;\n      } // Check to see if the action requires a full update of the liftedState.\n      // If it is a simple action generated by the user's app and the recording\n      // is not locked/paused, only send the action and the current state (fast).\n      //\n      // A full liftedState update (slow: serializes the entire liftedState) is\n      // only required when:\n      //   a) redux-devtools-extension fires the @@Init action (ignored by\n      //      @ngrx/store-devtools)\n      //   b) an action is generated by an @ngrx module (e.g. @ngrx/effects/init\n      //      or @ngrx/store/update-reducers)\n      //   c) the state has been recomputed due to time-traveling\n      //   d) any action that is not a PerformAction to err on the side of\n      //      caution.\n\n\n      if (action.type === PERFORM_ACTION) {\n        if (state.isLocked || state.isPaused) {\n          return;\n        }\n        /** @type {?} */\n\n\n        const currentState = unliftState(state);\n\n        if (shouldFilterActions(this.config) && isActionFiltered(currentState, action, this.config.predicate, this.config.actionsSafelist, this.config.actionsBlocklist)) {\n          return;\n        }\n        /** @type {?} */\n\n\n        const sanitizedState = this.config.stateSanitizer ? sanitizeState(this.config.stateSanitizer, currentState, state.currentStateIndex) : currentState;\n        /** @type {?} */\n\n        const sanitizedAction = this.config.actionSanitizer ? sanitizeAction(this.config.actionSanitizer, action, state.nextActionId) : action;\n        this.sendToReduxDevtools(\n        /**\n        * @return {?}\n        */\n        () => this.extensionConnection.send(sanitizedAction, sanitizedState));\n      } else {\n        // Requires full state update\n\n        /** @type {?} */\n        const sanitizedLiftedState = Object.assign(Object.assign({}, state), {\n          stagedActionIds: state.stagedActionIds,\n          actionsById: this.config.actionSanitizer ? sanitizeActions(this.config.actionSanitizer, state.actionsById) : state.actionsById,\n          computedStates: this.config.stateSanitizer ? sanitizeStates(this.config.stateSanitizer, state.computedStates) : state.computedStates\n        });\n        this.sendToReduxDevtools(\n        /**\n        * @return {?}\n        */\n        () => this.devtoolsExtension.send(null, sanitizedLiftedState, this.getExtensionConfig(this.config)));\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    createChangesObservable() {\n      if (!this.devtoolsExtension) {\n        return empty();\n      }\n\n      return new Observable(\n      /**\n      * @param {?} subscriber\n      * @return {?}\n      */\n      subscriber => {\n        /** @type {?} */\n        const connection = this.devtoolsExtension.connect(this.getExtensionConfig(this.config));\n        this.extensionConnection = connection;\n        connection.init();\n        connection.subscribe(\n        /**\n        * @param {?} change\n        * @return {?}\n        */\n        change => subscriber.next(change));\n        return connection.unsubscribe;\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    createActionStreams() {\n      // Listens to all changes\n\n      /** @type {?} */\n      const changes$ = this.createChangesObservable().pipe(share()); // Listen for the start action\n\n      /** @type {?} */\n\n      const start$ = changes$.pipe(filter(\n      /**\n      * @param {?} change\n      * @return {?}\n      */\n      change => change.type === ExtensionActionTypes.START)); // Listen for the stop action\n\n      /** @type {?} */\n\n      const stop$ = changes$.pipe(filter(\n      /**\n      * @param {?} change\n      * @return {?}\n      */\n      change => change.type === ExtensionActionTypes.STOP)); // Listen for lifted actions\n\n      /** @type {?} */\n\n      const liftedActions$ = changes$.pipe(filter(\n      /**\n      * @param {?} change\n      * @return {?}\n      */\n      change => change.type === ExtensionActionTypes.DISPATCH), map(\n      /**\n      * @param {?} change\n      * @return {?}\n      */\n      change => this.unwrapAction(change.payload)), concatMap(\n      /**\n      * @param {?} action\n      * @return {?}\n      */\n      action => {\n        if (action.type === IMPORT_STATE) {\n          // State imports may happen in two situations:\n          // 1. Explicitly by user\n          // 2. User activated the \"persist state accross reloads\" option\n          //    and now the state is imported during reload.\n          // Because of option 2, we need to give possible\n          // lazy loaded reducers time to instantiate.\n          // As soon as there is no UPDATE action within 1 second,\n          // it is assumed that all reducers are loaded.\n          return this.dispatcher.pipe(filter(\n          /**\n          * @param {?} action\n          * @return {?}\n          */\n          action => action.type === UPDATE), timeout(1000), debounceTime(1000), map(\n          /**\n          * @return {?}\n          */\n          () => action), catchError(\n          /**\n          * @return {?}\n          */\n          () => of(action)), take(1));\n        } else {\n          return of(action);\n        }\n      })); // Listen for unlifted actions\n\n      /** @type {?} */\n\n      const actions$ = changes$.pipe(filter(\n      /**\n      * @param {?} change\n      * @return {?}\n      */\n      change => change.type === ExtensionActionTypes.ACTION), map(\n      /**\n      * @param {?} change\n      * @return {?}\n      */\n      change => this.unwrapAction(change.payload)));\n      /** @type {?} */\n\n      const actionsUntilStop$ = actions$.pipe(takeUntil(stop$));\n      /** @type {?} */\n\n      const liftedUntilStop$ = liftedActions$.pipe(takeUntil(stop$));\n      this.start$ = start$.pipe(takeUntil(stop$)); // Only take the action sources between the start/stop events\n\n      this.actions$ = this.start$.pipe(switchMap(\n      /**\n      * @return {?}\n      */\n      () => actionsUntilStop$));\n      this.liftedActions$ = this.start$.pipe(switchMap(\n      /**\n      * @return {?}\n      */\n      () => liftedUntilStop$));\n    }\n    /**\n     * @private\n     * @param {?} action\n     * @return {?}\n     */\n\n\n    unwrapAction(action) {\n      return typeof action === 'string' ? eval(`(${action})`) : action;\n    }\n    /**\n     * @private\n     * @param {?} config\n     * @return {?}\n     */\n\n\n    getExtensionConfig(config) {\n      /** @type {?} */\n      const extensionOptions = {\n        name: config.name,\n        features: config.features,\n        serialize: config.serialize\n      };\n\n      if (config.maxAge !== false\n      /* support === 0 */\n      ) {\n        extensionOptions.maxAge = config.maxAge;\n      }\n\n      return extensionOptions;\n    }\n    /**\n     * @private\n     * @param {?} send\n     * @return {?}\n     */\n\n\n    sendToReduxDevtools(send) {\n      try {\n        send();\n      } catch (err) {\n        console.warn('@ngrx/store-devtools: something went wrong inside the redux devtools', err);\n      }\n    }\n\n  }\n\n  DevtoolsExtension.ɵfac = function DevtoolsExtension_Factory(t) {\n    return new (t || DevtoolsExtension)(ɵngcc0.ɵɵinject(REDUX_DEVTOOLS_EXTENSION), ɵngcc0.ɵɵinject(STORE_DEVTOOLS_CONFIG), ɵngcc0.ɵɵinject(DevtoolsDispatcher));\n  };\n\n  DevtoolsExtension.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: DevtoolsExtension,\n    factory: DevtoolsExtension.ɵfac\n  });\n  /** @nocollapse */\n\n  return DevtoolsExtension;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  DevtoolsExtension.prototype.devtoolsExtension;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DevtoolsExtension.prototype.extensionConnection;\n  /** @type {?} */\n\n  DevtoolsExtension.prototype.liftedActions$;\n  /** @type {?} */\n\n  DevtoolsExtension.prototype.actions$;\n  /** @type {?} */\n\n  DevtoolsExtension.prototype.start$;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DevtoolsExtension.prototype.config;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DevtoolsExtension.prototype.dispatcher;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/reducer.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst INIT_ACTION = {\n  type: INIT\n};\n/** @type {?} */\n\nconst RECOMPUTE =\n/** @type {?} */\n'@ngrx/store-devtools/recompute';\n/** @type {?} */\n\nconst RECOMPUTE_ACTION = {\n  type: RECOMPUTE\n};\n/**\n * @record\n */\n\nfunction ComputedState() {}\n\nif (false) {\n  /** @type {?} */\n  ComputedState.prototype.state;\n  /** @type {?} */\n\n  ComputedState.prototype.error;\n}\n/**\n * @record\n */\n\n\nfunction LiftedAction() {}\n\nif (false) {\n  /** @type {?} */\n  LiftedAction.prototype.type;\n  /** @type {?} */\n\n  LiftedAction.prototype.action;\n}\n/**\n * @record\n */\n\n\nfunction LiftedActions() {}\n/**\n * @record\n */\n\n\nfunction LiftedState() {}\n\nif (false) {\n  /** @type {?} */\n  LiftedState.prototype.monitorState;\n  /** @type {?} */\n\n  LiftedState.prototype.nextActionId;\n  /** @type {?} */\n\n  LiftedState.prototype.actionsById;\n  /** @type {?} */\n\n  LiftedState.prototype.stagedActionIds;\n  /** @type {?} */\n\n  LiftedState.prototype.skippedActionIds;\n  /** @type {?} */\n\n  LiftedState.prototype.committedState;\n  /** @type {?} */\n\n  LiftedState.prototype.currentStateIndex;\n  /** @type {?} */\n\n  LiftedState.prototype.computedStates;\n  /** @type {?} */\n\n  LiftedState.prototype.isLocked;\n  /** @type {?} */\n\n  LiftedState.prototype.isPaused;\n}\n/**\n * Computes the next entry in the log by applying an action.\n * @param {?} reducer\n * @param {?} action\n * @param {?} state\n * @param {?} error\n * @param {?} errorHandler\n * @return {?}\n */\n\n\nfunction computeNextEntry(reducer, action, state, error, errorHandler) {\n  if (error) {\n    return {\n      state,\n      error: 'Interrupted by an error up the chain'\n    };\n  }\n  /** @type {?} */\n\n\n  let nextState = state;\n  /** @type {?} */\n\n  let nextError;\n\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    nextError = err.toString();\n    errorHandler.handleError(err.stack || err);\n  }\n\n  return {\n    state: nextState,\n    error: nextError\n  };\n}\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n * @param {?} computedStates\n * @param {?} minInvalidatedStateIndex\n * @param {?} reducer\n * @param {?} committedState\n * @param {?} actionsById\n * @param {?} stagedActionIds\n * @param {?} skippedActionIds\n * @param {?} errorHandler\n * @param {?} isPaused\n * @return {?}\n */\n\n\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (minInvalidatedStateIndex >= computedStates.length && computedStates.length === stagedActionIds.length) {\n    return computedStates;\n  }\n  /** @type {?} */\n\n\n  const nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex); // If the recording is paused, recompute all states up until the pause state,\n  // else recompute all states.\n\n  /** @type {?} */\n\n  const lastIncludedActionId = stagedActionIds.length - (isPaused ? 1 : 0);\n\n  for (let i = minInvalidatedStateIndex; i < lastIncludedActionId; i++) {\n    /** @type {?} */\n    const actionId = stagedActionIds[i];\n    /** @type {?} */\n\n    const action = actionsById[actionId].action;\n    /** @type {?} */\n\n    const previousEntry = nextComputedStates[i - 1];\n    /** @type {?} */\n\n    const previousState = previousEntry ? previousEntry.state : committedState;\n    /** @type {?} */\n\n    const previousError = previousEntry ? previousEntry.error : undefined;\n    /** @type {?} */\n\n    const shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    /** @type {?} */\n\n    const entry = shouldSkip ? previousEntry : computeNextEntry(reducer, action, previousState, previousError, errorHandler);\n    nextComputedStates.push(entry);\n  } // If the recording is paused, the last state will not be recomputed,\n  // because it's essentially not part of the state history.\n\n\n  if (isPaused) {\n    nextComputedStates.push(computedStates[computedStates.length - 1]);\n  }\n\n  return nextComputedStates;\n}\n/**\n * @param {?=} initialCommittedState\n * @param {?=} monitorReducer\n * @return {?}\n */\n\n\nfunction liftInitialState(initialCommittedState, monitorReducer) {\n  return {\n    monitorState: monitorReducer(undefined, {}),\n    nextActionId: 1,\n    actionsById: {\n      0: liftAction(INIT_ACTION)\n    },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: false,\n    isPaused: false\n  };\n}\n/**\n * Creates a history state reducer from an app's reducer.\n * @param {?} initialCommittedState\n * @param {?} initialLiftedState\n * @param {?} errorHandler\n * @param {?=} monitorReducer\n * @param {?=} options\n * @return {?}\n */\n\n\nfunction liftReducerWith(initialCommittedState, initialLiftedState, errorHandler, monitorReducer, options = {}) {\n  /**\n   * Manages how the history actions modify the history state.\n   */\n  return (\n    /**\n    * @param {?} reducer\n    * @return {?}\n    */\n    reducer =>\n    /**\n    * @param {?} liftedState\n    * @param {?} liftedAction\n    * @return {?}\n    */\n    (liftedState, liftedAction) => {\n      let {\n        monitorState,\n        actionsById,\n        nextActionId,\n        stagedActionIds,\n        skippedActionIds,\n        committedState,\n        currentStateIndex,\n        computedStates,\n        isLocked,\n        isPaused\n      } = liftedState || initialLiftedState;\n\n      if (!liftedState) {\n        // Prevent mutating initialLiftedState\n        actionsById = Object.create(actionsById);\n      }\n      /**\n       * @param {?} n\n       * @return {?}\n       */\n\n\n      function commitExcessActions(n) {\n        // Auto-commits n-number of excess actions.\n\n        /** @type {?} */\n        let excess = n;\n        /** @type {?} */\n\n        let idsToDelete = stagedActionIds.slice(1, excess + 1);\n\n        for (let i = 0; i < idsToDelete.length; i++) {\n          if (computedStates[i + 1].error) {\n            // Stop if error is found. Commit actions up to error.\n            excess = i;\n            idsToDelete = stagedActionIds.slice(1, excess + 1);\n            break;\n          } else {\n            delete actionsById[idsToDelete[i]];\n          }\n        }\n\n        skippedActionIds = skippedActionIds.filter(\n        /**\n        * @param {?} id\n        * @return {?}\n        */\n        id => idsToDelete.indexOf(id) === -1);\n        stagedActionIds = [0, ...stagedActionIds.slice(excess + 1)];\n        committedState = computedStates[excess].state;\n        computedStates = computedStates.slice(excess);\n        currentStateIndex = currentStateIndex > excess ? currentStateIndex - excess : 0;\n      }\n      /**\n       * @return {?}\n       */\n\n\n      function commitChanges() {\n        // Consider the last committed state the new starting point.\n        // Squash any staged actions into a single committed state.\n        actionsById = {\n          0: liftAction(INIT_ACTION)\n        };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState = computedStates[currentStateIndex].state;\n        currentStateIndex = 0;\n        computedStates = [];\n      } // By default, aggressively recompute every state whatever happens.\n      // This has O(n) performance, so we'll override this to a sensible\n      // value whenever we feel like we don't have to recompute the states.\n\n      /** @type {?} */\n\n\n      let minInvalidatedStateIndex = 0;\n\n      switch (liftedAction.type) {\n        case LOCK_CHANGES:\n          {\n            isLocked = liftedAction.status;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n\n        case PAUSE_RECORDING:\n          {\n            isPaused = liftedAction.status;\n\n            if (isPaused) {\n              // Add a pause action to signal the devtools-user the recording is paused.\n              // The corresponding state will be overwritten on each update to always contain\n              // the latest state (see Actions.PERFORM_ACTION).\n              stagedActionIds = [...stagedActionIds, nextActionId];\n              actionsById[nextActionId] = new PerformAction({\n                type: '@ngrx/devtools/pause'\n              }, +Date.now());\n              nextActionId++;\n              minInvalidatedStateIndex = stagedActionIds.length - 1;\n              computedStates = computedStates.concat(computedStates[computedStates.length - 1]);\n\n              if (currentStateIndex === stagedActionIds.length - 2) {\n                currentStateIndex++;\n              }\n\n              minInvalidatedStateIndex = Infinity;\n            } else {\n              commitChanges();\n            }\n\n            break;\n          }\n\n        case RESET:\n          {\n            // Get back to the state the store was created with.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = initialCommittedState;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n\n        case COMMIT:\n          {\n            commitChanges();\n            break;\n          }\n\n        case ROLLBACK:\n          {\n            // Forget about any staged actions.\n            // Start again from the last committed state.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n\n        case TOGGLE_ACTION:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            const {\n              id: actionId\n            } = liftedAction;\n            /** @type {?} */\n\n            const index = skippedActionIds.indexOf(actionId);\n\n            if (index === -1) {\n              skippedActionIds = [actionId, ...skippedActionIds];\n            } else {\n              skippedActionIds = skippedActionIds.filter(\n              /**\n              * @param {?} id\n              * @return {?}\n              */\n              id => id !== actionId);\n            } // Optimization: we know history before this action hasn't changed\n\n\n            minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n            break;\n          }\n\n        case SET_ACTIONS_ACTIVE:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            const {\n              start,\n              end,\n              active\n            } = liftedAction;\n            /** @type {?} */\n\n            const actionIds = [];\n\n            for (let i = start; i < end; i++) actionIds.push(i);\n\n            if (active) {\n              skippedActionIds = difference(skippedActionIds, actionIds);\n            } else {\n              skippedActionIds = [...skippedActionIds, ...actionIds];\n            } // Optimization: we know history before this action hasn't changed\n\n\n            minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n            break;\n          }\n\n        case JUMP_TO_STATE:\n          {\n            // Without recomputing anything, move the pointer that tell us\n            // which state is considered the current one. Useful for sliders.\n            currentStateIndex = liftedAction.index; // Optimization: we know the history has not changed.\n\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n\n        case JUMP_TO_ACTION:\n          {\n            // Jumps to a corresponding state to a specific action.\n            // Useful when filtering actions.\n\n            /** @type {?} */\n            const index = stagedActionIds.indexOf(liftedAction.actionId);\n            if (index !== -1) currentStateIndex = index;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n\n        case SWEEP:\n          {\n            // Forget any actions that are currently being skipped.\n            stagedActionIds = difference(stagedActionIds, skippedActionIds);\n            skippedActionIds = [];\n            currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n            break;\n          }\n\n        case PERFORM_ACTION:\n          {\n            // Ignore action and return state as is if recording is locked\n            if (isLocked) {\n              return liftedState || initialLiftedState;\n            }\n\n            if (isPaused || liftedState && isActionFiltered(liftedState.computedStates[currentStateIndex], liftedAction, options.predicate, options.actionsSafelist, options.actionsBlocklist)) {\n              // If recording is paused or if the action should be ignored, overwrite the last state\n              // (corresponds to the pause action) and keep everything else as is.\n              // This way, the app gets the new current state while the devtools\n              // do not record another action.\n\n              /** @type {?} */\n              const lastState = computedStates[computedStates.length - 1];\n              computedStates = [...computedStates.slice(0, -1), computeNextEntry(reducer, liftedAction.action, lastState.state, lastState.error, errorHandler)];\n              minInvalidatedStateIndex = Infinity;\n              break;\n            } // Auto-commit as new actions come in.\n\n\n            if (options.maxAge && stagedActionIds.length === options.maxAge) {\n              commitExcessActions(1);\n            }\n\n            if (currentStateIndex === stagedActionIds.length - 1) {\n              currentStateIndex++;\n            }\n            /** @type {?} */\n\n\n            const actionId = nextActionId++; // Mutation! This is the hottest path, and we optimize on purpose.\n            // It is safe because we set a new key in a cache dictionary.\n\n            actionsById[actionId] = liftedAction;\n            stagedActionIds = [...stagedActionIds, actionId]; // Optimization: we know that only the new action needs computing.\n\n            minInvalidatedStateIndex = stagedActionIds.length - 1;\n            break;\n          }\n\n        case IMPORT_STATE:\n          {\n            // Completely replace everything.\n            ({\n              monitorState,\n              actionsById,\n              nextActionId,\n              stagedActionIds,\n              skippedActionIds,\n              committedState,\n              currentStateIndex,\n              computedStates,\n              isLocked,\n              // prettier-ignore\n              isPaused\n            } = liftedAction.nextLiftedState);\n            break;\n          }\n\n        case INIT:\n          {\n            // Always recompute states on hot reload and init.\n            minInvalidatedStateIndex = 0;\n\n            if (options.maxAge && stagedActionIds.length > options.maxAge) {\n              // States must be recomputed before committing excess.\n              computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n              commitExcessActions(stagedActionIds.length - options.maxAge); // Avoid double computation.\n\n              minInvalidatedStateIndex = Infinity;\n            }\n\n            break;\n          }\n\n        case UPDATE:\n          {\n            /** @type {?} */\n            const stateHasErrors = computedStates.filter(\n            /**\n            * @param {?} state\n            * @return {?}\n            */\n            state => state.error).length > 0;\n\n            if (stateHasErrors) {\n              // Recompute all states\n              minInvalidatedStateIndex = 0;\n\n              if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                // States must be recomputed before committing excess.\n                computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n                commitExcessActions(stagedActionIds.length - options.maxAge); // Avoid double computation.\n\n                minInvalidatedStateIndex = Infinity;\n              }\n            } else {\n              // If not paused/locked, add a new action to signal devtools-user\n              // that there was a reducer update.\n              if (!isPaused && !isLocked) {\n                if (currentStateIndex === stagedActionIds.length - 1) {\n                  currentStateIndex++;\n                } // Add a new action to only recompute state\n\n                /** @type {?} */\n\n\n                const actionId = nextActionId++;\n                actionsById[actionId] = new PerformAction(liftedAction, +Date.now());\n                stagedActionIds = [...stagedActionIds, actionId];\n                minInvalidatedStateIndex = stagedActionIds.length - 1;\n                computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n              } // Recompute state history with latest reducer and update action\n\n\n              computedStates = computedStates.map(\n              /**\n              * @param {?} cmp\n              * @return {?}\n              */\n              cmp => Object.assign(Object.assign({}, cmp), {\n                state: reducer(cmp.state, RECOMPUTE_ACTION)\n              }));\n              currentStateIndex = stagedActionIds.length - 1;\n\n              if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                commitExcessActions(stagedActionIds.length - options.maxAge);\n              } // Avoid double computation.\n\n\n              minInvalidatedStateIndex = Infinity;\n            }\n\n            break;\n          }\n\n        default:\n          {\n            // If the action is not recognized, it's a monitor action.\n            // Optimization: a monitor action can't change history.\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n      }\n\n      computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n      monitorState = monitorReducer(monitorState, liftedAction);\n      return {\n        monitorState,\n        actionsById,\n        nextActionId,\n        stagedActionIds,\n        skippedActionIds,\n        committedState,\n        currentStateIndex,\n        computedStates,\n        isLocked,\n        isPaused\n      };\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/devtools.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet StoreDevtools = /*#__PURE__*/(() => {\n  class StoreDevtools {\n    /**\n     * @param {?} dispatcher\n     * @param {?} actions$\n     * @param {?} reducers$\n     * @param {?} extension\n     * @param {?} scannedActions\n     * @param {?} errorHandler\n     * @param {?} initialState\n     * @param {?} config\n     */\n    constructor(dispatcher, actions$, reducers$, extension, scannedActions, errorHandler, initialState, config) {\n      /** @type {?} */\n      const liftedInitialState = liftInitialState(initialState, config.monitor);\n      /** @type {?} */\n\n      const liftReducer = liftReducerWith(initialState, liftedInitialState, errorHandler, config.monitor, config);\n      /** @type {?} */\n\n      const liftedAction$ = merge(merge(actions$.asObservable().pipe(skip(1)), extension.actions$).pipe(map(liftAction)), dispatcher, extension.liftedActions$).pipe(observeOn(queueScheduler));\n      /** @type {?} */\n\n      const liftedReducer$ = reducers$.pipe(map(liftReducer));\n      /** @type {?} */\n\n      const liftedStateSubject = new ReplaySubject(1);\n      /** @type {?} */\n\n      const liftedStateSubscription = liftedAction$.pipe(withLatestFrom(liftedReducer$), scan(\n      /**\n      * @param {?} __0\n      * @param {?} __1\n      * @return {?}\n      */\n      ({\n        state: liftedState\n      }, [action, reducer]) => {\n        /** @type {?} */\n        let reducedLiftedState = reducer(liftedState, action); // On full state update\n        // If we have actions filters, we must filter completely our lifted state to be sync with the extension\n\n        if (action.type !== PERFORM_ACTION && shouldFilterActions(config)) {\n          reducedLiftedState = filterLiftedState(reducedLiftedState, config.predicate, config.actionsSafelist, config.actionsBlocklist);\n        } // Extension should be sent the sanitized lifted state\n\n\n        extension.notify(action, reducedLiftedState);\n        return {\n          state: reducedLiftedState,\n          action\n        };\n      }, {\n        state: liftedInitialState,\n        action:\n        /** @type {?} */\n        null\n      })).subscribe(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      ({\n        state,\n        action\n      }) => {\n        liftedStateSubject.next(state);\n\n        if (action.type === PERFORM_ACTION) {\n          /** @type {?} */\n          const unliftedAction =\n          /** @type {?} */\n          action.action;\n          scannedActions.next(unliftedAction);\n        }\n      });\n      /** @type {?} */\n\n      const extensionStartSubscription = extension.start$.subscribe(\n      /**\n      * @return {?}\n      */\n      () => {\n        this.refresh();\n      });\n      /** @type {?} */\n\n      const liftedState$ =\n      /** @type {?} */\n      liftedStateSubject.asObservable();\n      /** @type {?} */\n\n      const state$ = liftedState$.pipe(map(unliftState));\n      this.extensionStartSubscription = extensionStartSubscription;\n      this.stateSubscription = liftedStateSubscription;\n      this.dispatcher = dispatcher;\n      this.liftedState = liftedState$;\n      this.state = state$;\n    }\n    /**\n     * @param {?} action\n     * @return {?}\n     */\n\n\n    dispatch(action) {\n      this.dispatcher.next(action);\n    }\n    /**\n     * @param {?} action\n     * @return {?}\n     */\n\n\n    next(action) {\n      this.dispatcher.next(action);\n    }\n    /**\n     * @param {?} error\n     * @return {?}\n     */\n\n\n    error(error) {}\n    /**\n     * @return {?}\n     */\n\n\n    complete() {}\n    /**\n     * @param {?} action\n     * @return {?}\n     */\n\n\n    performAction(action) {\n      this.dispatch(new PerformAction(action, +Date.now()));\n    }\n    /**\n     * @return {?}\n     */\n\n\n    refresh() {\n      this.dispatch(new Refresh());\n    }\n    /**\n     * @return {?}\n     */\n\n\n    reset() {\n      this.dispatch(new Reset(+Date.now()));\n    }\n    /**\n     * @return {?}\n     */\n\n\n    rollback() {\n      this.dispatch(new Rollback(+Date.now()));\n    }\n    /**\n     * @return {?}\n     */\n\n\n    commit() {\n      this.dispatch(new Commit(+Date.now()));\n    }\n    /**\n     * @return {?}\n     */\n\n\n    sweep() {\n      this.dispatch(new Sweep());\n    }\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n\n\n    toggleAction(id) {\n      this.dispatch(new ToggleAction(id));\n    }\n    /**\n     * @param {?} actionId\n     * @return {?}\n     */\n\n\n    jumpToAction(actionId) {\n      this.dispatch(new JumpToAction(actionId));\n    }\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n\n\n    jumpToState(index) {\n      this.dispatch(new JumpToState(index));\n    }\n    /**\n     * @param {?} nextLiftedState\n     * @return {?}\n     */\n\n\n    importState(nextLiftedState) {\n      this.dispatch(new ImportState(nextLiftedState));\n    }\n    /**\n     * @param {?} status\n     * @return {?}\n     */\n\n\n    lockChanges(status) {\n      this.dispatch(new LockChanges(status));\n    }\n    /**\n     * @param {?} status\n     * @return {?}\n     */\n\n\n    pauseRecording(status) {\n      this.dispatch(new PauseRecording(status));\n    }\n\n  }\n\n  StoreDevtools.ɵfac = function StoreDevtools_Factory(t) {\n    return new (t || StoreDevtools)(ɵngcc0.ɵɵinject(DevtoolsDispatcher), ɵngcc0.ɵɵinject(ɵngcc1.ActionsSubject), ɵngcc0.ɵɵinject(ɵngcc1.ReducerObservable), ɵngcc0.ɵɵinject(DevtoolsExtension), ɵngcc0.ɵɵinject(ɵngcc1.ScannedActionsSubject), ɵngcc0.ɵɵinject(ɵngcc0.ErrorHandler), ɵngcc0.ɵɵinject(INITIAL_STATE), ɵngcc0.ɵɵinject(STORE_DEVTOOLS_CONFIG));\n  };\n\n  StoreDevtools.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: StoreDevtools,\n    factory: StoreDevtools.ɵfac\n  });\n  /** @nocollapse */\n\n  return StoreDevtools;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  StoreDevtools.prototype.stateSubscription;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  StoreDevtools.prototype.extensionStartSubscription;\n  /** @type {?} */\n\n  StoreDevtools.prototype.dispatcher;\n  /** @type {?} */\n\n  StoreDevtools.prototype.liftedState;\n  /** @type {?} */\n\n  StoreDevtools.prototype.state;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/instrument.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst IS_EXTENSION_OR_MONITOR_PRESENT = new InjectionToken('Is Devtools Extension or Monitor Present');\n/**\n * @param {?} extension\n * @param {?} config\n * @return {?}\n */\n\nfunction createIsExtensionOrMonitorPresent(extension, config) {\n  return Boolean(extension) || config.monitor !== noMonitor;\n}\n/**\n * @return {?}\n */\n\n\nfunction createReduxDevtoolsExtension() {\n  /** @type {?} */\n  const extensionKey = '__REDUX_DEVTOOLS_EXTENSION__';\n\n  if (typeof window === 'object' && typeof\n  /** @type {?} */\n  window[extensionKey] !== 'undefined') {\n    return (\n      /** @type {?} */\n      window[extensionKey]\n    );\n  } else {\n    return null;\n  }\n}\n/**\n * @param {?} devtools\n * @return {?}\n */\n\n\nfunction createStateObservable(devtools) {\n  return devtools.state;\n}\n\nlet StoreDevtoolsModule = /*#__PURE__*/(() => {\n  class StoreDevtoolsModule {\n    /**\n     * @param {?=} options\n     * @return {?}\n     */\n    static instrument(options = {}) {\n      return {\n        ngModule: StoreDevtoolsModule,\n        providers: [DevtoolsExtension, DevtoolsDispatcher, StoreDevtools, {\n          provide: INITIAL_OPTIONS,\n          useValue: options\n        }, {\n          provide: IS_EXTENSION_OR_MONITOR_PRESENT,\n          deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG],\n          useFactory: createIsExtensionOrMonitorPresent\n        }, {\n          provide: REDUX_DEVTOOLS_EXTENSION,\n          useFactory: createReduxDevtoolsExtension\n        }, {\n          provide: STORE_DEVTOOLS_CONFIG,\n          deps: [INITIAL_OPTIONS],\n          useFactory: createConfig\n        }, {\n          provide: StateObservable,\n          deps: [StoreDevtools],\n          useFactory: createStateObservable\n        }, {\n          provide: ReducerManagerDispatcher,\n          useExisting: DevtoolsDispatcher\n        }]\n      };\n    }\n\n  }\n\n  StoreDevtoolsModule.ɵfac = function StoreDevtoolsModule_Factory(t) {\n    return new (t || StoreDevtoolsModule)();\n  };\n\n  StoreDevtoolsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: StoreDevtoolsModule\n  });\n  StoreDevtoolsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return StoreDevtoolsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: src/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: ngrx-store-devtools.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { INITIAL_OPTIONS, RECOMPUTE, StoreDevtools, StoreDevtoolsConfig, StoreDevtoolsModule, IS_EXTENSION_OR_MONITOR_PRESENT as ɵa, createIsExtensionOrMonitorPresent as ɵb, createReduxDevtoolsExtension as ɵc, createStateObservable as ɵd, STORE_DEVTOOLS_CONFIG as ɵe, noMonitor as ɵf, createConfig as ɵg, REDUX_DEVTOOLS_EXTENSION as ɵh, DevtoolsExtension as ɵi, DevtoolsDispatcher as ɵj }; //# sourceMappingURL=ngrx-store-devtools.js.map","map":null,"metadata":{},"sourceType":"module"}